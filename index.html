<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouBuddy Index.html</title>
    <script src="cordova.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
    <style>
      
    .loading-message {
        padding: 20px;
        text-align: center;
        color: #888;
    }
    .error-message {
        padding: 20px;
        text-align: center;
        color: #f44336;
    }
                * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: black;
            color: #fff;
            line-height: 1.6;
            
        }
        .container {
    width: 97vw;
    max-width: 375px;
    height: 97vh;
    max-height: 770px;
    margin: 0 auto;
    background-color: #000000;
    margin-bottom: 0;
    overflow-y: auto;
    position: relative;
    scrollbar-width: none;
    display: flex;
    flex-direction: column;
    overflow-x: hidden;
    justify-content: center;
            align-items: center;
}

        .mobile-container {
            position: relative;
            width: 97vw; /* Adjusts to 90% of the viewport width */
            max-width: 375px; /* Original width as the maximum limit */
            height: 97vh; /* Adjusts to 90% of the viewport height */
            max-height: 770px; /* Original height as the maximum limit */
            margin: 0 auto;
            
            overflow-x: hidden;
            overflow-y: hidden;
            background: black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;

            
        }
        @media (min-width: 768px) {
            .container {
                width: 50vw; /* Adjust for larger screens */
                height: 80vh;
            }
        }

        .content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            text-align: center;
            padding-bottom: 80px; /* Space for taskbar */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* Internet Explorer 10+ */
            overflow-x: hidden;
            justify-content: center;
            align-items: center;
            
            
        }

        .content::-webkit-scrollbar { 
            width: 0px; 
            background: transparent; /* Chrome/Safari/Webkit */
        }

        .menu-btn {
    position: absolute;
    top: 50%; /* Center vertically relative to the header */
    left: 20px; /* Distance from the left edge */
    transform: translateY(-50%); /* Offset for vertical centering */
    font-size: 24px;
    background: black;
    border: none;
    color: white;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    z-index: 1000;
    transition: 0.3s ease-in-out;
}

        .side-menu {
            height: 100%;
            width: 0;
            position: fixed;
            z-index: 1001;
            top: 0;
            left: 0;
            background-color: #1a1a1a;
            overflow-x: hidden;
            transition: 0.5s;
            padding-top: 60px;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5);
        }

        .side-menu a {
            padding: 15px 25px;
            text-decoration: none;
            font-size: 18px;
            color: #fff;
            display: block;
            transition: 0.3s;
            border-left: 3px solid transparent;
        }

        .side-menu a:hover {
            background-color: #2d2d2d;
            border-left: 3px solid #4CAF50;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 25px;
            font-size: 30px;
            color: #fff;
        }

        

        

        /* Updated Taskbar Styles */
        .taskbar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 1000;
            border-top: 1px solid #333;
            max-width: 375px;
            margin: 0 auto;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 5px;
        }

        .taskbar-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            transition: 0.3s;
            
            

        }
        #universityTaskbarBtn {
            
            margin: 0 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            transition: 0.3s;
        }
        #universityTaskbarText {
            transform: scale(1) translateY(-8px);
            margin: 0 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            transition: 0.3s;
        }

        

        .taskbar-btn-icon {
            font-size: 24px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .taskbar-btn-icon svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        .taskbar-btn span {
            font-size: 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 60px;
            text-align: center;
        }

        .taskbar-btn:hover, .taskbar-btn.university-selected {
            color: #4CAF50;
           
        }







        .container::-webkit-scrollbar {
            display: none;
        }
    
        @media (min-width: 768px) {
            .container {
                width: 50vw;
                height: 80vh;
            }
        }
    
        


    
.header.hidden {
    transform: translateY(-100%); /* Moves the header upwards smoothly */
    opacity: 0; /* Gradually fades out */
    pointer-events: none; /* Prevent interaction when hidden */
    height: 0;
    
}


    
.header h1 {
    color: #4CAF50;
    margin: 0; /* Remove default margins */
    font-size: 22px;
    margin-right: 10px; /* Add space between menu button and h1 */
}
        
        .header p {
            color: #ffffff;
        }
    
        
    
        .post-container {
    max-width: 600px;
    margin: 0 auto;
    padding: 16px;
}

/* Styling individual posts with thin shadow line */
.post {
    padding: 16px;
    margin-bottom: 12px;
    background-color: #000000;
    color: #ffffff;
    box-shadow: inset 0 -0.2px 0 rgba(230, 230, 230, 0.5); /* Thin shadow line at the bottom */
    position: relative;
}

/* Styling for the post header */
.post-header {
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: flex-start;
}
/* Styling for the heading, similar to Twitter/X heading size */
.post-heading {
    font-weight: 600; /* Bold heading */
    font-size: 16px; /* Larger heading size */
    line-height: 1.25;
    color: #ffffff;
    margin: 0; /* Removes default margin */
    padding: 0; /* Removes any default padding */
    letter-spacing: 0.5px; /* Slight letter spacing for readability */
    text-align: left; /* Aligns text to the left */
}

/* Text content of the post, matched to Twitter/X text size */
.text-post {
    font-size: 15px; /* Smaller text size */
    line-height: 1.5;
    color: #ffffff;
    white-space: pre-wrap; /* Ensures wrapping of text */
    word-wrap: break-word; /* Prevents overflow */
    margin: 0; /* Removes default margin */
    padding: 0; /* Removes any default padding */
    font-weight: 350; /* Light text weight */
    text-align: left; /* Aligns text to the left */
}

/* Caption styling to align left and match text size of tweets */
.caption {
    font-weight: 600; /* Bold heading */
    font-size: 16px; /* Larger heading size */
    line-height: 1.25;
    color: #ffffff;
    margin: 0; /* Removes default margin */
    padding: 0; /* Removes any default padding */
    letter-spacing: 0.5px; /* Slight letter spacing for readability */
    text-align: left; /* Aligns text to the left */
}
        .media-container {
            margin: 12px 0;
            overflow: hidden;
            background-color: #1c1c1c;
        }
    
        .media-container img,
        .media-container video {
            width: 100%;
            height: auto;
            display: block;
            cursor: pointer;
        }
        
    
        .timestamp {
            font-size: 12px;
            color: #7a7a7a;
            
            text-align: right; /* Align timestamp to the right */
    margin-top: 8px; /* Space between text and timestamp */
        }
    
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            cursor: pointer;
        }
    
        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90%;
            max-height: 90vh;
        }
    
        .back-to-top {
    position: fixed;
    bottom: 70px;
    right: 20px;
    background: linear-gradient(45deg, #4CAF50, #45a049);
    color: white;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    display: none;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    border: none;
    font-size: 34px;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.back-to-top.visible {
    opacity: 1;
    display: flex;
}

        .refresh-indicator {
            text-align: center;
            padding: 10px;
            color: #4CAF50;
            display: none;
        }

        .end-message {
            background-color: #4CAF50;
            color: white;
            font-size: 18px;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            margin-top: 20px;
        }
        


        .header {
    position: fixed;
    top: 5px;
    background-color: #000000;
    padding: 22px;
    z-index: 1000;
    text-align: center;
    width: 100%;
    transition: all 0.6s ease-in-out;
    
    overflow: hidden;
    display: flex;
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
    position: fixed;
    top: 5px;
    font-size: 12px;     
            
            width: 100%;
            height: 20px;
            
}

.feed {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
    
    transition: margin-top 0.6s ease-in-out;
    overflow-x: hidden;
}

/* Add new loading styles */
.loading-container {
    position: fixed;
    top: 0;
    width: 100%;
    text-align: center;
    padding: 10px;
    background-color: #000000;
    z-index: 9;
}

.loading-circle {
    width: 40px;
    height: 40px;
    margin: 0 auto;
    border: 3px solid #4CAF50;
    border-radius: 50%;
    border-top-color: transparent;
    animation: spin 1s linear infinite;
}

.loading-text {
    margin-top: 8px;
    color: #4CAF50;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
        




.feed.expand-top {
    margin-top: 0; /* Smoothly move the posts container to the top */
}
#feed.shift-up {
    transform: translateY(-50px); /* Adjust the value to match the header height */
}





.post-bottom-bar {
    display: flex;
    justify-content: space-between; /* Change back to space-between */
    align-items: center;
    margin-top: 10px;
}

.save-icon {
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    user-select: none;
    color: #888;
    transition: color 0.3s;
}

.save-icon.saved {
    color: #4CAF50;
}

.save-icon.saved svg {
    fill: #4CAF50;
    stroke: #4CAF50;
}
.timestamp {
    font-size: 12px;
    color: #7a7a7a;
}


.mcq-post {
        background: #000;
        padding: 20px;
        margin-bottom: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .mcq-question {
        font-size: 16px;
        color: #fff;
        margin-bottom: 20px;
        line-height: 1.5;
        font-weight: 500;
    }

    .mcq-options {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .mcq-option {
        width: 100%;
        padding: 12px 16px;
        border: 1px solid #333;
        background: transparent;
        color: #fff;
        border-radius: 8px;
        text-align: left;
        font-size: 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        outline: none;
    }

    

    .mcq-option.correct {
        background: #1b4d1b;
        border-color: #2e7d32;
    }

    .mcq-option.incorrect {
        background: #4d1b1b;
        border-color: #7d2e2e;
    }

    .mcq-feedback {
        margin-top: 16px;
        padding: 12px;
        border-radius: 6px;
        font-size: 14px;
        line-height: 1.4;
    }

    .feedback-correct {
        background: #1b4d1b;
        color: #fff;
        padding: 12px;
        border-radius: 6px;
    }

    .feedback-incorrect {
        background: #4d1b1b;
        color: #fff;
        padding: 12px;
        border-radius: 6px;
    }

    .mcq-post.answered .mcq-option:not(.selected) {
        opacity: 0.7;
    }


    .post-loading {
    opacity: 0;
    animation: fadeIn 0.3s ease forwards;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.gif-overlay {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0, 0, 0, 0.7);
    padding: 4px 8px;
    border-radius: 4px;
    z-index: 1;
}

.gif-indicator {
    color: white;
    font-size: 12px;
    font-weight: bold;
}




* {
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0); /* Disable highlight on Android Chrome/WebView */
    tap-highlight-color: rgba(0, 0, 0, 0);        /* Disable highlight on other Android browsers */
    outline: none;                                /* Remove outline for better UI */
    touch-action: manipulation;                  /* Optimize touch behavior */
    -webkit-user-select: none;                   /* Prevent selection */
    user-select: none;                           /* Prevent selection for other browsers */
    -webkit-touch-callout: none;                 /* Disable callout menu on long press */
}







        
    </style>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
</head>
<body>
    <div class="mobile-container">
        <div class="content" id="homePage">
            
            <div id="sideMenu" class="side-menu">
                <a href="javascript:void(0)" class="close-btn" onclick="closeMenu()">&times;</a>
                <a href="#" id="universityOption">University</a>
                <a href="./gamelist.html">Play Amazing Games</a>
                <a href="./aboutus.html">About Us</a>
                <a href="./switch.html">Switch University</a>
                <a href="./courses.html">Free Courses</a>
                <a href="./portfolio.html">Meet the Founder</a>
                <a href="./QRscanner.html">QR Testing</a>
                
            </div>
            <div class="container">
                <div class="header" id="header">
                    <h1>YouBuddy</h1>
                    <button class="menu-btn" onclick="openMenu()">☰</button>
                    
                </div>

                <div id="savedHeader" class="header" style="display: none;">
                    <h1>Saved Posts</h1>
                </div>
                
                <div class="feed" id="feed"></div>
                
                <!-- Add the saved section here -->
                <div id="savedSection" style="display: none;">
                    <div id="savedPostsContainer"></div>
                </div>
                
                
                
            </div>
            <div class="modal" id="mediaModal">
                <img class="modal-content" id="modalContent">
            </div>
            <button class="back-to-top" id="backToTop">↑</button>

            
            <div class="taskbar">
                <button class="taskbar-btn" onclick="navigateToProfile()">
                    <div class="taskbar-btn-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                            <circle cx="12" cy="7" r="4"></circle>
                        </svg>
                    </div>
                    <span>Profile</span>
                </button>
                <button class="taskbar-btn" onclick="navigateToAboutUs()">
                    <div class="taskbar-btn-icon">
                        <img src="./youbuddylogo (2) (1) (1).jpg" alt="Chatbot Icon" style="width: 24px; height: 24px;">
                    </div>
                    <span>About Us</span>
                </button>
                <button id="universityTaskbarBtn" class="taskbar-btn university-selected" onclick="handleUniversityNavigation()">
                    <div class="taskbar-btn-icon">🎓</div>
                    <span id="universityTaskbarText">Select Uni</span>
                </button>
                
                <button class="taskbar-btn" onclick="navigateToChatbot()">
                    <div class="taskbar-btn-icon">
                        <!-- Replace the SVG with an image -->
                        <img src="./boticonblack.jpg" alt="Chatbot Icon" style="width: 24px; height: 24px;">
                    </div>
                    <span>Chatbot</span>
                </button>
                
                <button class="taskbar-btn" onclick="navigateToGames()">
                    <div class="taskbar-btn-icon">🎮</div>
                    <span>Games</span>
                </button>
            </div>
        </div>
    </div>

<script>
        

        function openMenu() {
            document.getElementById("sideMenu").style.width = "250px";
        }

        function closeMenu() {
            document.getElementById("sideMenu").style.width = "0";
        }

        function handleUniversityNavigation() {
            const universityPath = localStorage.getItem("universityPath");
            if (universityPath) {
                window.location.href = universityPath;
            } else {
                window.location.href = "./switch.html";
            }
        }

        function navigateToUniversity() {
            const universityPath = localStorage.getItem("universityPath");
            if (universityPath) {
                window.location.href = universityPath;
            } else {
                window.location.href = "./switch.html";
            }
        }

        function navigateToProfile() {
            window.location.href = "./userprofile.html";
        }

        function navigateToAboutUs() {
            window.location.href = "./aboutus.html";
        }

        function navigateToChatbot() {
            window.location.href = "./chatbot.html";
        }
        

        function navigateToGames() {
            window.location.href = "./gamelist.html";
        }

        window.onload = function() {
            const selectedUniversity = localStorage.getItem("selectedUniversity");
            const universityTaskbarText = document.getElementById("universityTaskbarText");
            const universityOption = document.getElementById("universityOption");
            const universityPath = localStorage.getItem("universityPath");
            
            if (selectedUniversity && universityPath) {
                const words = selectedUniversity.split(' ');
                const midPoint = Math.ceil(words.length / 2);
                const firstHalf = words.slice(0, midPoint).join(' ');
                const secondHalf = words.slice(midPoint).join(' ');
                universityTaskbarText.innerHTML = `${firstHalf}<br>${secondHalf}`;
                universityOption.innerHTML = selectedUniversity;
                universityOption.href = universityPath;
            } else {
                universityTaskbarText.innerHTML = "Select<br>Uni";
                universityOption.innerHTML = "Select University";
            }
            

            // Auto-slide functionality
            setInterval(nextSlide, 6000);
        };







// Supabase configuration
const SUPABASE_URL = 'https://rbkqhwyinwvrtusmuipu.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJia3Fod3lpbnd2cnR1c211aXB1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzc0Nzc3ODMsImV4cCI6MjA1MzA1Mzc4M30.jnyb8aSAsAdOYI_6U8jwP4LCxjX0LNUzIih2KdiOHkU';


console.log("Supabase loaded:", typeof window.supabase !== 'undefined');

// DOM Elements
const feedContainer = document.getElementById('feed');
const backToTop = document.getElementById('backToTop');
const header = document.getElementById('header');


async function testSupabase() {
    try {
        const client = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        const { data, error } = await client.from('tweets').select('count');
        console.log("Connection test:", data, error);
        return !error;
    } catch (e) {
        console.error("Connection test failed:", e);
        return false;
    }
}

// Variables
// Variables
let tweets = [];
let youtubeVideos = [];
let images = [];
let videos = [];
let gifs = [];
let mcqs = [];
let pinnedTweet = null;
let isLoading = false;
let lastScrollTop = 0;
let currentBatch = 0;
const POST_LIMIT = 10;
let isEndMessageDisplayed = false;
let displayedContent = {
    text: new Set(),
    youtube: new Set(), // Add this line
    image: new Set(),
    video: new Set(),
    gif: new Set(),
    mcq: new Set()
};

// Initialize supabase client
let supabaseClient;


// Add these variables to your variables section
let isPulling = false;
let pullStartY = 0;
let pullDistance = 0;
const PULL_THRESHOLD = 80; // Pixels to pull down before refresh triggers

// Main function to initialize app
async function initApp() {
    try {
        console.log("Initializing app...");
        
        // Show loading state
        feedContainer.innerHTML = '<div class="loading-message">Connecting to database...</div>';
        
        // Initialize Supabase
        if (typeof supabase === 'undefined') {
            // Check if window.supabase exists
            if (typeof window.supabase === 'undefined') {
                throw new Error("Supabase client not available. Make sure to include the Supabase JS script in your HTML.");
            }
            supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        } else {
            // If global supabase object exists
            supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        }
        
        console.log("Supabase client initialized");
        
        // Fetch content
        await fetchAllContent();
        
        // Setup event listeners
        setupEventListeners();
        
    } catch (error) {
        console.error("Initialization error:", error);
        feedContainer.innerHTML = `<div class="error-message">Error: ${error.message}<br>Make sure you've included the Supabase JS script in your HTML.</div>`;
    }
}
// Add this to your variables section
let contentCycles = {
    'text': { shown: new Set(), total: 0 },
    'youtube': { shown: new Set(), total: 0 }, // Add this line
    'image': { shown: new Set(), total: 0 },
    'video': { shown: new Set(), total: 0 },
    'gif': { shown: new Set(), total: 0 },
    'mcq': { shown: new Set(), total: 0 }
};

// Fetch all content from Supabase
// Fetch all content from Supabase
// Fetch all content from Supabase
// Fetch all content from Supabase
async function fetchAllContent() {
    try {
        feedContainer.innerHTML = '<div class="loading-message">Loading content...</div>';
        
        console.log("Fetching pinned tweets...");
        const { data: pinnedData, error: pinnedError } = await supabaseClient
            .from('pinned_tweets')
            .select('*')
            .eq('hidden', false) // Only get non-hidden pinned tweets
            .order('pinned_date', { ascending: false })
            .limit(1);
        
        if (pinnedError) throw pinnedError;
        pinnedTweet = pinnedData && pinnedData.length > 0 ? pinnedData[0] : null;
        console.log(`Fetched pinned tweet:`, pinnedTweet);
        
        // Clear loading message and start feed
        feedContainer.innerHTML = '';
        
        // Display pinned tweet first if exists
        if (pinnedTweet) {
            const pinnedElement = createPinnedTweetElement(pinnedTweet);
            feedContainer.appendChild(pinnedElement);
        }
        
        // Load a small batch of initial posts
        await loadInitialPosts();
        
        // Then fetch remaining content in background
        fetchContentInBackground();
    } catch (error) {
        console.error("Error fetching content:", error);
        feedContainer.innerHTML = `<div class="error-message">Failed to load content: ${error.message}</div>`;
    }
}

// Load initial posts fast
async function loadInitialPosts() {
    try {
        // Get a small, curated set for immediate display
        console.log("Loading initial posts...");
        const initialCounts = {
            tweets: 4, 
            images: 2,
            videos: 1,
            youtubeVideos: 1,
            gifs: 1,
            mcqs: 1
        };
        
        // Fetch initial tweets
        const { data: initialTweets, error: tweetsError } = await supabaseClient
            .from('tweets')
            .select('*')
            .limit(initialCounts.tweets);
        
        if (tweetsError) throw tweetsError;
        tweets = initialTweets || [];
        
        // Fetch initial images
        const { data: initialImages, error: imagesError } = await supabaseClient
            .from('images')
            .select('*')
            .limit(initialCounts.images);
        
        if (imagesError) throw imagesError;
        images = initialImages || [];
        
        // Fetch initial videos
        const { data: initialVideos, error: videosError } = await supabaseClient
            .from('videos')
            .select('*')
            .limit(initialCounts.videos);
        
        if (videosError) throw videosError;
        videos = initialVideos || [];
        
        // Fetch initial YouTube videos
        const { data: initialYouTube, error: youtubeError } = await supabaseClient
            .from('youtube_videos')
            .select('*')
            .limit(initialCounts.youtubeVideos);
        
        if (youtubeError) throw youtubeError;
        youtubeVideos = initialYouTube || [];
        
        // Fetch initial GIFs
        const { data: initialGifs, error: gifsError } = await supabaseClient
            .from('gifs')
            .select('*')
            .limit(initialCounts.gifs);
        
        if (gifsError) throw gifsError;
        gifs = initialGifs || [];
        
        // Fetch initial MCQs
        const { data: initialMcqs, error: mcqsError } = await supabaseClient
            .from('mcqs')
            .select('*')
            .limit(initialCounts.mcqs);
        
        if (mcqsError) throw mcqsError;
        mcqs = initialMcqs || [];
        
        // Update content cycle totals with what we have so far
        contentCycles.text.total = tweets.length;
        contentCycles.image.total = images.length;
        contentCycles.video.total = videos.length;
        contentCycles.youtube.total = youtubeVideos.length;
        contentCycles.gif.total = gifs.length;
        contentCycles.mcq.total = mcqs.length;
        
        // Clear any previously shown content tracking
        Object.keys(contentCycles).forEach(type => {
            contentCycles[type].shown.clear();
        });
        
        // Load the initial posts to feed
        loadPosts();
        
        console.log("Initial posts loaded");
    } catch (error) {
        console.error("Error loading initial posts:", error);
        throw error;
    }
}

// Fetch remaining content in background
async function fetchContentInBackground() {
    try {
        console.log("Fetching remaining content in background...");
        
        // Fetch all tweets (beyond what we've loaded initially)
        const { data: allTweets, error: tweetsError } = await supabaseClient
            .from('tweets')
            .select('*');
        
        if (!tweetsError && allTweets) {
            tweets = allTweets;
            contentCycles.text.total = tweets.length;
        }
        
        // Fetch all images
        const { data: allImages, error: imagesError } = await supabaseClient
            .from('images')
            .select('*');
        
        if (!imagesError && allImages) {
            images = allImages;
            contentCycles.image.total = images.length;
        }
        
        // Fetch all videos
        const { data: allVideos, error: videosError } = await supabaseClient
            .from('videos')
            .select('*');
        
        if (!videosError && allVideos) {
            videos = allVideos;
            contentCycles.video.total = videos.length;
        }
        
        // Fetch all YouTube videos
        const { data: allYouTube, error: youtubeError } = await supabaseClient
            .from('youtube_videos')
            .select('*');
        
        if (!youtubeError && allYouTube) {
            youtubeVideos = allYouTube;
            contentCycles.youtube.total = youtubeVideos.length;
        }
        
        // Fetch all GIFs
        const { data: allGifs, error: gifsError } = await supabaseClient
            .from('gifs')
            .select('*');
        
        if (!gifsError && allGifs) {
            gifs = allGifs;
            contentCycles.gif.total = gifs.length;
        }
        
        // Fetch all MCQs
        const { data: allMcqs, error: mcqsError } = await supabaseClient
            .from('mcqs')
            .select('*');
        
        if (!mcqsError && allMcqs) {
            mcqs = allMcqs;
            contentCycles.mcq.total = mcqs.length;
        }
        
        console.log("Background content loading complete");
    } catch (error) {
        console.error("Error fetching background content:", error);
        // Don't throw error here - we've already shown initial content
    }
}
// Create pinned tweet element
// Create pinned tweet element
function createPinnedTweetElement(content) {
    const post = document.createElement('div');
    post.className = 'post pinned-post';
    post.dataset.postId = content.id;

    const timeFormatted = content.time || '12:00 PM'; // or whatever time you store
    const dateFormatted = content.timestamp || 'Apr 6, 2025';

    post.innerHTML = `
        <div class="pinned-indicator">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 2L12 22"></path>
                <path d="M6 6L18 18"></path>
            </svg>
            Pinned
        </div>
        <div class="post-header">
            ${content.dp_url ? `<img src="${content.dp_url}" alt="Profile" class="profile-pic zoomable-dp">` : '<div class="profile-pic-placeholder"></div>'}
            <div class="user-info">
                <span class="display-name">${content.heading}</span>
                <span class="username">${content.username || 'username'}</span>
            </div>
        </div>
        <div class="text-post">${content.text}</div>
        <div class="tweet-footer-time">${timeFormatted} · ${dateFormatted}</div>

        <!-- Zoom modal -->
        <div class="dp-modal">
            <div class="dp-modal-inner">
                <span class="dp-close">&times;</span>
                <img src="${content.dp_url}" class="dp-modal-content">
            </div>
        </div>
    `;

    // Zoom functionality
    const img = post.querySelector('.zoomable-dp');
    const modal = post.querySelector('.dp-modal');
    const closeBtn = post.querySelector('.dp-close');

    img.addEventListener('click', () => {
        modal.style.display = 'flex';
    });

    closeBtn.addEventListener('click', () => {
        modal.style.display = 'none';
    });

    return post;
}





// Setup event listeners
function setupEventListeners() {
    // Scroll event for infinite loading
    feedContainer.addEventListener('scroll', () => {
        const scrollTop = feedContainer.scrollTop;
        const { scrollHeight, clientHeight } = feedContainer;
        
        // Header visibility
        if (scrollTop > lastScrollTop) {
            header.style.transform = 'translateY(-100%)';
        } else {
            header.style.transform = 'translateY(0)';
        }
        
        lastScrollTop = scrollTop <= 0 ? 0 : scrollTop;
        
        // Back to top button visibility
        if (scrollTop > 100) {
            backToTop.classList.add('visible');
        } else {
            backToTop.classList.remove('visible');
        }
        
        // Load more content when near bottom
        const scrollPercentage = (scrollTop + clientHeight) / scrollHeight;
        if (scrollPercentage > 0.7 && !isLoading) {
            isLoading = true;
            loadPosts();
            isLoading = false;
        }
    });
    
    // Add pull-to-refresh functionality
    setupPullToRefresh();
    
    // Back to top button
    backToTop.addEventListener('click', () => {
        feedContainer.scrollTo({ top: 0, behavior: 'smooth' });
        refreshFeed();
    });
}

// Refresh feed
// Refresh feed
// Refresh feed
// New function to setup pull-to-refresh
function setupPullToRefresh() {
    // Create pull-to-refresh indicator element
    const refreshIndicator = document.createElement('div');
    refreshIndicator.className = 'pull-refresh-indicator';
    refreshIndicator.innerHTML = '<div class="refresh-spinner"></div><span>Release to refresh</span>';
    refreshIndicator.style.position = 'absolute';
    refreshIndicator.style.top = '-60px';
    refreshIndicator.style.left = '0';
    refreshIndicator.style.width = '100%';
    refreshIndicator.style.height = '60px';
    refreshIndicator.style.display = 'flex';
    refreshIndicator.style.alignItems = 'center';
    refreshIndicator.style.justifyContent = 'center';
    refreshIndicator.style.transition = 'transform 0.2s';
    refreshIndicator.style.zIndex = '1000';
    document.querySelector('#feed').insertAdjacentElement('beforebegin', refreshIndicator);
    
    // Touch start event
    feedContainer.addEventListener('touchstart', (e) => {
        if (feedContainer.scrollTop === 0) {
            isPulling = true;
            pullStartY = e.touches[0].clientY;
            pullDistance = 0;
        }
    });
    
    // Touch move event
    feedContainer.addEventListener('touchmove', (e) => {
        if (!isPulling) return;
        
        const touchY = e.touches[0].clientY;
        pullDistance = touchY - pullStartY;
        
        if (pullDistance > 0) {
            e.preventDefault(); // Prevent default scroll
            
            // Calculate resistance factor - gets harder to pull the further you go
            const resistance = pullDistance > 100 ? 0.2 : 0.5;
            const translateY = Math.min(pullDistance * resistance, PULL_THRESHOLD);
            
            feedContainer.style.transform = `translateY(${translateY}px)`;
            refreshIndicator.style.transform = `translateY(${translateY}px)`;
            
            // Update indicator text
            const refreshText = refreshIndicator.querySelector('span');
            if (translateY >= PULL_THRESHOLD) {
                refreshText.textContent = 'Release to refresh';
            } else {
                refreshText.textContent = 'Pull to refresh';
            }
        }
    }, { passive: false });
    
    // Fix the touchend event in setupPullToRefresh
feedContainer.addEventListener('touchend', () => {
    if (!isPulling) return;
    
    // Reset pulling state
    isPulling = false;
    
    // Animate back to original position
    feedContainer.style.transition = 'transform 0.3s';
    refreshIndicator.style.transition = 'transform 0.3s';
    feedContainer.style.transform = '';
    refreshIndicator.style.transform = '';
    
    // Reset transitions after animation
    setTimeout(() => {
        feedContainer.style.transition = '';
        refreshIndicator.style.transition = '';
    }, 300);
    
    // If pulled far enough, refresh feed
    if (pullDistance >= PULL_THRESHOLD) {
        // Show loading spinner while refreshing
        const refreshText = refreshIndicator.querySelector('span');
        refreshText.textContent = 'Refreshing...';
        
        // Properly call refreshFeed
        refreshFeed();
    }
});
}
// Load posts into feed
function loadPosts() {
    // Get content for this batch
    const contentItems = getContentBatch();
    
    if (contentItems.length === 0) {
        if (!isEndMessageDisplayed) {
            const endMessage = document.createElement('div');
            endMessage.className = 'post end-message';
            endMessage.textContent = "That's all for now! Click the arrow to see new content";
            feedContainer.appendChild(endMessage);
            isEndMessageDisplayed = true;
        }
        return;
    }
    
    // Add content to feed
    contentItems.forEach(item => {
        const element = createContentElement(item);
        if (element) {
            feedContainer.appendChild(element);
        }
    });
    
    currentBatch++;
}

// Get a batch of content
// Get a batch of content
// Modify getContentBatch to use the content cycles
function getContentBatch() {
    const result = [];
    const types = ['text', 'youtube', 'image', 'mcq', 'video', 'gif']; // Add 'youtube'
    const contentArrays = {
        'text': tweets,
        'youtube': youtubeVideos, // Add this line
        'image': images,
        'video': videos,
        'gif': gifs,
        'mcq': mcqs
    };
    
    // Calculate how many of each type to include
    const itemsPerType = Math.ceil(POST_LIMIT / types.length);
    
    // For each type in sequence
    for (let i = 0; i < types.length; i++) {
        const typeIndex = (i + currentBatch) % types.length;
        const type = types[typeIndex];
        
        const contentArray = contentArrays[type];
        if (contentArray && contentArray.length > 0) {
            // Get items of this type
            const typedContent = contentArray.map(item => ({
                ...item,
                type: type,
                contentId: type + '-' + (item.id || Math.random().toString(36).substr(2, 9))
            }));
            
            // Check if we've shown all content of this type in the current cycle
            if (contentCycles[type].shown.size >= contentCycles[type].total) {
                // Reset for this type if we've shown everything
                contentCycles[type].shown.clear();
                console.log(`Completed full cycle of ${type} content, reshuffling...`);
            }
            
            // Filter out already shown content in this cycle
            const filteredContent = typedContent.filter(item => 
                !contentCycles[type].shown.has(item.contentId)
            );
            
            // If we somehow have no content left, skip this type
            if (filteredContent.length === 0) {
                continue;
            }
            
            // Shuffle available content of this type
            for (let j = filteredContent.length - 1; j > 0; j--) {
                const k = Math.floor(Math.random() * (j + 1));
                [filteredContent[j], filteredContent[k]] = [filteredContent[k], filteredContent[j]];
            }
            
            // Take one item of this type
            const selectedItem = filteredContent[0];
            contentCycles[type].shown.add(selectedItem.contentId);
            
            // Also track it in the display set for this session
            displayedContent[type].add(selectedItem.contentId);
            
            result.push(selectedItem);
        }
    }
    
    return result;
}

// Update refreshFeed to reset the content cycles too
function refreshFeed() {
    feedContainer.innerHTML = '<div class="loading-message">Refreshing content...</div>';
    isEndMessageDisplayed = false;
    currentBatch = 0;
    
    // Reset display tracking
    Object.keys(displayedContent).forEach(type => {
        displayedContent[type].clear();
    });
    
    // Reset content cycles - this will force a fresh shuffle on next load
    Object.keys(contentCycles).forEach(type => {
        contentCycles[type].shown.clear();
    });
    
    // Fetch fresh content from the database
    fetchAllContent();
}
// Create content element based on type
function createContentElement(content) {
    if (content.type === 'mcq') {
        return createMCQElement(content);
    } else {
        return createPostElement(content);
    }
}

// Create post element
function createPostElement(content) {
    if (content.type === 'mcq') return null;
    
    const post = document.createElement('div');
    post.className = 'post';
    post.dataset.postId = content.id;
    post.style.opacity = '1';

    if (content.type === 'text') {
        post.innerHTML = `
            <div class="post-heading">${content.heading}</div>
            <div class="text-post">${content.text}</div>
            <div class="timestamp">${content.timestamp}</div>
        `;
    } else if (content.type === 'image') {
        post.innerHTML = `
            ${content.caption ? `<div class="text-post">${content.caption}</div>` : ''}
            <div class="media-container" data-type="image">
                <img src="${content.url}" 
                     alt="${content.caption || 'Media content'}" 
                     loading="lazy" 
                     decoding="async">
            </div>
            <div class="timestamp">${content.timestamp}</div>
        `;
    } else if (content.type === 'video') {
        post.innerHTML = `
            ${content.caption ? `<div class="text-post">${content.caption}</div>` : ''}
            <div class="media-container" data-type="video">
                <div class="video-wrapper">
                    <video 
                        controls
                        playsinline 
                        loop
                        preload="none"
                        class="feed-video"
                        style="width: 100%; height: 100%; object-fit: cover;"
                    >
                        <source src="${content.url}" type="video/mp4">
                    </video>
                </div>
            </div>
            <div class="timestamp">${content.timestamp}</div>
        `;

        const video = post.querySelector('video');
        setupVideoAutoplay(video);

    
    } 
   // Modify your createPostElement function's YouTube section
else if (content.type === 'youtube') {
    // Generate a unique ID for each YouTube iframe
    const youtubeId = 'youtube-' + content.video_id + '-' + Math.floor(Math.random() * 10000);
    
    post.innerHTML = `
        <div class="post-heading">${content.caption || 'YouTube Video'}</div>
        <div class="media-container youtube-container" data-type="youtube" style="pointer-events: auto;">
            <div class="video-wrapper youtube-wrapper" data-video-id="${content.video_id}" id="${youtubeId}-container">
                <!-- We'll create the iframe programmatically to ensure API control -->
                <div id="${youtubeId}"></div>
            </div>
        </div>
        <div class="timestamp">${content.timestamp}</div>
    `;
    
    // Create YouTube player once the element is added to DOM
    setTimeout(() => {
        createYouTubePlayer(youtubeId, content.video_id);
    }, 100);
}

// Define a global object to store YouTube player instances
if (!window.youtubePlayers) {
    window.youtubePlayers = {};
}

else if (content.type === 'gif') {
        post.innerHTML = `
            ${content.caption ? `<div class="text-post">${content.caption}</div>` : ''}
            <div class="media-container gif-container" data-type="gif">
                <div class="gif-overlay">
                    <span class="gif-indicator">GIF</span>
                </div>
                <img src="${content.url}" 
                     alt="${content.caption || 'GIF content'}" 
                     class="gif-media"
                     loading="lazy" 
                     decoding="async">
            </div>
            <div class="timestamp">${content.timestamp}</div>
        `;

        const gifImg = post.querySelector('.gif-media');
        setupGifAutoplay(gifImg);
    }

    const mediaContainer = post.querySelector('.media-container');
if (mediaContainer) {
    if (content.type === 'video' || content.type === 'youtube') {
        // Allow pointer events on video AND YouTube elements
        mediaContainer.style.pointerEvents = 'auto';
    } else {
        mediaContainer.style.pointerEvents = 'none';
    }
}
    return post;
}
// Function to create a YouTube player with API control
function createYouTubePlayer(elementId, videoId) {
    // Only proceed if YT API is loaded
    if (typeof YT !== 'undefined' && YT.Player) {
        // Create the player
        const player = new YT.Player(elementId, {
            videoId: videoId,
            playerVars: {
                'autoplay': 0,
                'controls': 1,
                'rel': 0,
                'fs': 1, // Allow fullscreen
                'modestbranding': 1
            },
            events: {
                'onReady': onPlayerReady
            }
        });
        
        // Store the player instance
        window.youtubePlayers[elementId] = player;
        
        // Set up intersection observer for this player
        observeYouTubePlayer(elementId);
    } else {
        // If YT API isn't loaded yet, load it
        if (!document.getElementById('youtube-api-script')) {
            const tag = document.createElement('script');
            tag.id = 'youtube-api-script';
            tag.src = 'https://www.youtube.com/iframe_api';
            const firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
            
            // Set up callback for when API loads
            window.onYouTubeIframeAPIReady = function() {
                createYouTubePlayer(elementId, videoId);
            };
        } else {
            // API script is loading, try again in a moment
            setTimeout(() => {
                createYouTubePlayer(elementId, videoId);
            }, 500);
        }
    }
}

// When player is ready, do nothing (we'll control it with the observer)
function onPlayerReady(event) {
    // Player is ready
    console.log('YouTube player ready');
}

// Function to observe YouTube player visibility
function observeYouTubePlayer(playerId) {
    const container = document.getElementById(playerId + '-container');
    if (!container) return;
    
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            const player = window.youtubePlayers[playerId];
            if (!player) return;
            
            if (entry.isIntersecting) {
                // Video is visible, enable it
                console.log('YouTube video visible');
                // We don't auto-play, just make sure it's enabled
            } else {
                // Video is not visible, stop it
                console.log('YouTube video not visible, stopping');
                try {
                    player.pauseVideo();
                    // Optional: you can also stop and reset the video completely
                    // player.stopVideo();
                } catch (e) {
                    console.error('Error stopping YouTube video:', e);
                }
            }
        });
    }, {
        root: document.getElementById('feed'),
        rootMargin: '0px',
        threshold: 0.2 // Video will pause when less than 20% visible
    });
    
    observer.observe(container);
}

// Add this new function to handle YouTube autoplay
function setupYouTubeAutoplay(iframeElement, videoId) {
    // Create a unique ID if not already present
    if (!iframeElement.id) {
        iframeElement.id = 'youtube-' + videoId + '-' + Math.random().toString(36).substr(2, 9);
    }
    
    // Store the player reference in a global object
    if (!window.youtubePlayers) {
        window.youtubePlayers = {};
    }
    // Function to be called when the YouTube API is ready
    const onYouTubeIframeAPIReady = () => {
        window.youtubePlayers[iframeElement.id] = new YT.Player(iframeElement.id, {
            events: {
                'onReady': (event) => {
                    // Player is ready, now set up the intersection observer
                    const options = {
                        root: document.getElementById('feed'),
                        rootMargin: '50px 0px',
                        threshold: 0.5
                    };
                    
                    const observer = new IntersectionObserver((entries, observer) => {
                        entries.forEach(entry => {
                            const player = window.youtubePlayers[iframeElement.id];
                            if (player && typeof player.getPlayerState === 'function') {
                                if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
                                    // Only play if the video is not already playing
                                    if (player.getPlayerState() !== YT.PlayerState.PLAYING) {
                                        player.playVideo();
                                    }
                                } else {
                                    // Pause the video when out of view
                                    if (player.getPlayerState() === YT.PlayerState.PLAYING) {
                                        player.pauseVideo();
                                    }
                                }
                            }
                        });
                    }, options);
                    
                    observer.observe(iframeElement.parentNode);
                }
            }
        });
    };
    
    // Check if YouTube API is already loaded
    if (window.YT && window.YT.Player) {
        onYouTubeIframeAPIReady();
    } else {
        // Add a callback to the window object for when API loads
        window.onYouTubeIframeAPIReady = () => {
            // Call for all pending iframes
            Object.keys(window.youtubePlayers).forEach(id => {
                if (!window.youtubePlayers[id] || typeof window.youtubePlayers[id].getPlayerState !== 'function') {
                    onYouTubeIframeAPIReady();
                }
            });
        };
    }
}


// Modify videoAutoplay to use lower quality settings and less aggressive preloading
function setupVideoAutoplay(videoElement) {
    videoElement.preload = 'metadata';
    
    const options = {
        root: document.getElementById('feed'),
        rootMargin: '50px 0px', // Reduced from 200px
        threshold: 0.5 // Reduced from 0.70
    };

    const observer = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
                videoElement.preload = 'auto';
                videoElement.currentTime = 0;
                videoElement.play().catch(error => {
                    console.warn('Autoplay failed:', error);
                });
            } else {
                videoElement.pause();
                videoElement.currentTime = 0;
                videoElement.preload = 'none';
            }
        });
    }, options);

    observer.observe(videoElement);
}

// Modify GIF autoplay to be less aggressive
function setupGifAutoplay(gifElement) {
    gifElement.loading = 'lazy';
    gifElement.decoding = 'async';
    
    const originalSrc = gifElement.src;
    const options = {
        root: document.getElementById('feed'),
        rootMargin: '50px 0px', // Reduced from 200px
        threshold: 0.1
    };

    const observer = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                gifElement.src = originalSrc;
                gifElement.style.visibility = 'visible';
            } else {
                gifElement.style.visibility = 'hidden';
            }
        });
    }, options);

    observer.observe(gifElement);
}




// Create MCQ element
function createMCQElement(mcq) {
    const mcqElement = document.createElement('div');
    mcqElement.className = 'mcq-post';
    mcqElement.dataset.mcqId = mcq.id;
    
    // Handle options safely
    let options = mcq.options;
    if (typeof options === 'string') {
        try {
            options = JSON.parse(options);
        } catch (e) {
            console.error('Error parsing MCQ options:', e);
            options = [
                { text: "Option A", isCorrect: false },
                { text: "Option B", isCorrect: true }
            ];
        }
    }
    
    // Fallback for malformed options
    if (!Array.isArray(options) || options.length === 0) {
        options = [
            { text: "Option A", isCorrect: false },
            { text: "Option B", isCorrect: true }
        ];
    }
    
    mcqElement.innerHTML = `
        <div class="mcq-question">${mcq.question || 'Question not available'}</div>
        <div class="mcq-options">
            ${options.map((option, index) => `
                <button class="mcq-option" data-index="${index}">
                    ${String.fromCharCode(65 + index)}. ${option.text}
                </button>
            `).join('')}
        </div>
        <div class="mcq-feedback"></div>
    `;
    
    // Add event listeners for MCQ options
    const optionButtons = mcqElement.querySelectorAll('.mcq-option');
    const feedbackDiv = mcqElement.querySelector('.mcq-feedback');
    
    optionButtons.forEach((option) => {
        option.addEventListener('click', () => {
            if (mcqElement.classList.contains('answered')) return;
            
            const selectedIndex = parseInt(option.dataset.index);
            const isCorrect = options[selectedIndex].isCorrect;
            
            optionButtons.forEach(opt => opt.classList.remove('correct', 'incorrect', 'selected'));
            option.classList.add(isCorrect ? 'correct' : 'incorrect', 'selected');
            
            feedbackDiv.innerHTML = `
                <div class="feedback-${isCorrect ? 'correct' : 'incorrect'}">
                    ${isCorrect ? 
                        `✓ Correct! ${mcq.explanation || ''}` : 
                        `✗ Incorrect. The correct answer is ${options.find(opt => opt.isCorrect)?.text || 'Not available'}. ${mcq.explanation || ''}`}
                </div>
            `;
            
            mcqElement.classList.add('answered');
        });
    });
    
    return mcqElement;
}

// Add CSS styles
function addStyles() {
    const styles = `

    .offline-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 50vh;
    text-align: center;
    padding: 20px;
}

.offline-image {
    max-width: 200px;
    margin-bottom: 20px;
}

.loading-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 200px;
    width: 100%;
}

.loading-gif {
    width: 80px;
    height: 80px;
}
.video-wrapper {
    position: relative;
    width: 100%;
    padding-bottom: 177.78%; /* This creates a 9:16 aspect ratio (vertical) */
    height: 0;
    overflow: hidden;
    max-height: 80vh; /* Limit maximum height */
    border-radius: 8px;
}

.video-wrapper video,
.video-wrapper iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: contain; /* This ensures the video stays in proper ratio */
}

    .youtube-container {
    aspect-ratio: 16/9;
    width: 100%;
    border-radius: 8px;
    overflow: hidden;
    margin: 10px 0;
    pointer-events: auto !important; /* Force pointer events to be enabled */
}

.youtube-container iframe {
    border-radius: 8px;
    pointer-events: auto !important; /* Ensure iframe can receive clicks */
}



/* Add this to your CSS */
.refresh-spinner {
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-top-color: #333;
    border-radius: 50%;
    margin-right: 10px;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}







  .user-info {
    display: flex;
    flex-direction: column;
    line-height: 1.2;
}

.display-name {
    font-weight: bold;
    font-size: 1em;
    margin-bottom: 2px;
    text-align: left;
}

.username {
    font-size: 0.85em;
    color: gray;
}

.text-post {
    font-size: 1em;
    margin-top: 8px;
    margin-bottom: 6px;
}
.tweet-footer-time {
    font-size: 0.8em;
    color: gray;
    margin-top: 4px;
    text-align: left;
}

/* Zoomable DP Modal */
.dp-modal {
    display: none;
    position: fixed;
    z-index: 9999;
    left: 0; top: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    justify-content: center;
    align-items: center;
}

.dp-modal-inner {
    position: relative;
    width: 300px;
    height: 300px;
    max-width: 90vw;
    max-height: 90vw;
    display: flex;
    justify-content: center;
    align-items: center;
}

.dp-modal-content {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 10px;
    box-shadow: 0 0 20px #000;
}

.dp-close {
    position: absolute;
    top: -10px;
    right: -10px;
    font-size: 28px;
    color: white;
    background: black;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    line-height: 30px;
    text-align: center;
    cursor: pointer;
    z-index: 10000;
}







  

    .post-header {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
}

.profile-pic {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
    object-fit: cover;
}

.profile-pic-placeholder {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
    background-color: #e1e8ed;
}

.post-heading {
    font-weight: bold;
    font-size: 1.1em;
}

    .pinned-post {
    border-left: 3px solid #1da1f2;
    background-color: rgba(29,161,242,0.05);
}

.pinned-indicator {
    display: flex;
    align-items: center;
    color: #1da1f2;
    font-size: 0.8em;
    margin-bottom: 8px;
    font-weight: 600;
}

.pinned-indicator svg {
    margin-right: 4px;
}
      .loading-message {
        padding: 20px;
        text-align: center;
        color: #888;
      }
      .error-message {
        padding: 20px;
        text-align: center;
        color: #f44336;
      }
      
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: 'Segoe UI', system-ui, sans-serif;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        tap-highlight-color: rgba(0, 0, 0, 0);
        outline: none;
        touch-action: manipulation;
        -webkit-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: black;
        color: #fff;
        line-height: 1.6;
      }
      
      .container {
        width: 97vw;
        max-width: 375px;
        height: 97vh;
        max-height: 770px;
        margin: 0 auto;
        background-color: #000000;
        margin-bottom: 0;
        overflow-y: auto;
        position: relative;
        scrollbar-width: none;
        display: flex;
        flex-direction: column;
        overflow-x: hidden;
        justify-content: center;
        align-items: center;
      }

      .container::-webkit-scrollbar {
        display: none;
      }
      
      @media (min-width: 768px) {
        .container {
          width: 50vw;
          height: 80vh;
        }
      }
      
      .post {
        padding: 16px;
        margin-bottom: 12px;
        background-color: #000000;
        color: #ffffff;
        box-shadow: inset 0 -0.2px 0 rgba(230, 230, 230, 0.5);
        position: relative;
      }
      
      .post-header {
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        justify-content: flex-start;
      }
      
      .post-heading {
        font-weight: 600;
        font-size: 16px;
        line-height: 1.25;
        color: #ffffff;
        margin: 0;
        padding: 0;
        letter-spacing: 0.5px;
        text-align: left;
      }
      
      .text-post {
        font-size: 15px;
        line-height: 1.5;
        color: #ffffff;
        white-space: pre-wrap;
        word-wrap: break-word;
        margin: 0;
        padding: 0;
        font-weight: 350;
        text-align: left;
      }
      
      .caption {
        font-weight: 600;
        font-size: 16px;
        line-height: 1.25;
        color: #ffffff;
        margin: 0;
        padding: 0;
        letter-spacing: 0.5px;
        text-align: left;
      }
      
      .media-container {
        margin: 12px 0;
        overflow: hidden;
        background-color: #1c1c1c;
      }
      
      .media-container img,
      .media-container video {
        width: 100%;
        height: auto;
        display: block;
        cursor: pointer;
      }
      
      .timestamp {
        font-size: 12px;
        color: #7a7a7a;
        text-align: right;
        margin-top: 8px;
      }
      
      .mcq-post {
        background: #000;
        padding: 20px;
        margin-bottom: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .mcq-question {
        font-size: 16px;
        color: #fff;
        margin-bottom: 20px;
        line-height: 1.5;
        font-weight: 500;
      }
      
      .mcq-options {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      
      .mcq-option {
        width: 100%;
        padding: 12px 16px;
        border: 1px solid #333;
        background: transparent;
        color: #fff;
        border-radius: 8px;
        text-align: left;
        font-size: 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        outline: none;
      }
      
      .mcq-option.correct {
        background: #1b4d1b;
        border-color: #2e7d32;
      }
      
      .mcq-option.incorrect {
        background: #4d1b1b;
        border-color: #7d2e2e;
      }
      
      .mcq-feedback {
        margin-top: 16px;
        padding: 12px;
        border-radius: 6px;
        font-size: 14px;
        line-height: 1.4;
      }
      
      .feedback-correct {
        background: #1b4d1b;
        color: #fff;
        padding: 12px;
        border-radius: 6px;
      }
      
      .feedback-incorrect {
        background: #4d1b1b;
        color: #fff;
        padding: 12px;
        border-radius: 6px;
      }
      
      .mcq-post.answered .mcq-option:not(.selected) {
        opacity: 0.7;
      }
      
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        z-index: 1000;
        cursor: pointer;
      }
      
      .modal-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        max-width: 90%;
        max-height: 90vh;
      }
      
      .back-to-top {
        position: fixed;
        bottom: 70px;
        right: 20px;
        background: linear-gradient(45deg, #4CAF50, #45a049);
        color: white;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        display: none;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        border: none;
        font-size: 34px;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      .back-to-top.visible {
        opacity: 1;
        display: flex;
      }
      
      .post-loading {
        opacity: 0;
        animation: fadeIn 0.3s ease forwards;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      
      .gif-overlay {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        padding: 4px 8px;
        border-radius: 4px;
        z-index: 1;
      }
      
      .gif-indicator {
        color: white;
        font-size: 12px;
        font-weight: bold;
      }
      
      .header {
        position: fixed;
        top: 5px;
        background-color: #000000;
        padding: 22px;
        z-index: 1000;
        text-align: center;
        width: 100%;
        transition: all 0.6s ease-in-out;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 20px;
        font-size: 12px;
      }
      
      .header.hidden {
        transform: translateY(-100%);
        opacity: 0;
        pointer-events: none;
        height: 0;
      }
      
      .header h1 {
        color: #4CAF50;
        margin: 0;
        font-size: 22px;
        margin-right: 10px;
      }
      
      .header p {
        color: #ffffff;
      }
      
      .feed {
        flex: 1;
        overflow-y: auto;
        padding: 8px;
        transition: margin-top 0.6s ease-in-out;
        overflow-x: hidden;
      }
      
      .feed.expand-top {
        margin-top: 0;
      }
      
      #feed.shift-up {
        transform: translateY(-50px);
      }
      
      .loading-container {
        position: fixed;
        top: 0;
        width: 100%;
        text-align: center;
        padding: 10px;
        background-color: #000000;
        z-index: 9;
      }
      
      .loading-circle {
        width: 40px;
        height: 40px;
        margin: 0 auto;
        border: 3px solid #4CAF50;
        border-radius: 50%;
        border-top-color: transparent;
        animation: spin 1s linear infinite;
      }
      
      .loading-text {
        margin-top: 8px;
        color: #4CAF50;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      .post-bottom-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 10px;
      }
      
      .save-icon {
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        user-select: none;
        color: #888;
        transition: color 0.3s;
      }
      
      .save-icon.saved {
        color: #4CAF50;
      }
      
      .save-icon.saved svg {
        fill: #4CAF50;
        stroke: #4CAF50;
      }
      
      .refresh-indicator {
        text-align: center;
        padding: 10px;
        color: #4CAF50;
        display: none;
      }
      
      .end-message {
        background-color: #4CAF50;
        color: white;
        font-size: 18px;
        padding: 10px;
        border-radius: 5px;
        text-align: center;
        margin-top: 20px;
      }
    `;

    
    const styleElement = document.createElement('style');
    styleElement.textContent = styles;
    document.head.appendChild(styleElement);
}

// Initialize the app when the document is ready
document.addEventListener('DOMContentLoaded', () => {
    addStyles();
    initApp();
});
</script>
</body>
</html>